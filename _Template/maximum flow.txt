vector<vector<int>> w;
vector<vector<int>> nc; //network capacity
vector<vector<int>> nf; //network flow
vector<int> trace;
int N;

void doFlow(int start, int end) {
    int now, next;
    queue<int> _q; // Using BFS to track flux
    _q.push(start);
    while (!_q.empty()) {
        now = _q.front();
        _q.pop();
        for (int i = 0; i < w[now].size(); i++) {
            next = w[now][i];
            if (nc[now][next] - nf[now][next] > 0 && trace[next] == -1) {
                _q.push(next);
                trace[next] = now;
                if (next == end) return;
            }
        }
    }
    return;
}

int maximumFlow(int start, int end) {
    /*============================================
    vector<vector<int>> w : adj graph (init with size : N)
    vector<vector<int>> nc : value for i-j Capacity (init with size : N * N)
    vector<vector<int>> nf : value for i-j Flow (init with size : N * N)
    vector<int> trace : keep X's parent to trace (init with size : N, value : -1)
    ============================================*/
    int now, next, f, result;
    result = 0;
    while (true) {
        trace.clear();
        trace.resize(N, -1);
        doFlow(start, end);
        if (trace[end] == -1) break;
        f = 1e9; //MAX value
        for (now = end; now != start; now = trace[now]) f = min(f, nc[trace[now]][now] - nf[trace[now]][now]);
        for (now = end; now != start; now = trace[now]) {
            nf[trace[now]][now] += f;
            nf[now][trace[now]] -= f;
        }
        result += f;
    }
    return result;
}